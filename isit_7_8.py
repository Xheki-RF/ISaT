# -*- coding: utf-8 -*-
"""isit_7-8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10VwOU47PTwT5-03sWGn84atJ2KumbN5x
"""

pip install umap-learn

pip install umap

"""#Unpacking and encoding dataframe#"""

import pandas as pd

# Reading data from csv
df = pd.read_csv("ecoli.data", sep="\s+", names=["Sequence name",  "mcg", "gvh", "lip", "chg", "aac", "alm1", "alm2", "class"])

df

from itertools import count
import seaborn as sns
import umap.umap_ as umap
import numpy as np
from sklearn.manifold import TSNE
from sklearn.preprocessing import LabelEncoder

df_one_hot = pd.get_dummies(df, columns=["Sequence name"])

le = LabelEncoder()
df_one_hot["class"] = le.fit_transform(df["class"])

df_one_hot

# Counting amount of each class
df_one_hot["class"].value_counts()

from sklearn.model_selection import train_test_split

# Separating original data on test and train
X_train_og, X_test_og, y_train_og, y_test_og = train_test_split(df_one_hot.loc[:, df_one_hot.columns != "class"], df_one_hot["class"],
                                                    test_size=0.3, shuffle=True)


# SVM
X_test_svm_og = X_test_og
y_test_svm_og = y_test_og

# KNN
X_test_knn_og = X_test_og
y_test_knn_og = y_test_og

# RF
X_test_rf_og = X_test_og
y_test_rf_og = y_test_og

"""#Functions section#

T-SNE
"""

def t_sne_draw(encoded_dataframe, n_components, perplexity, angle):
  X_embedded = TSNE(n_components=n_components, perplexity=perplexity, angle=angle).fit_transform(encoded_dataframe)
  X, Y = X_embedded[:, 0], X_embedded[:, 1]
  sns.scatterplot(x=X, y=Y, hue=encoded_dataframe["class"], palette="deep")

"""UMAP"""

def umap_draw(encoded_dataframe, n_components, n_neighbors, min_dist):
  reducer = umap.UMAP(n_neighbors=n_neighbors, min_dist=min_dist, n_components=n_components, metric='euclidean')
  embedding = reducer.fit_transform(encoded_dataframe)
  X_umap, Y_umap = embedding[:, 0], embedding[:, 1]
  sns.scatterplot(x=X_umap, y=Y_umap, hue=encoded_dataframe["class"], palette="deep")

"""#Resampling data using SMOTE#"""

from imblearn.over_sampling import SMOTE

sm = SMOTE(random_state=42, k_neighbors=1, n_jobs=4, sampling_strategy="not majority")
X_smote, y_sm = sm.fit_resample(df_one_hot.loc[:, df_one_hot.columns != "class"], df_one_hot["class"])

# Merging X and y into one dataframe
y_smote = pd.DataFrame(y_sm)
y_smote.reset_index(drop=True, inplace=True)
df_smote = pd.concat([X_smote, y_smote], axis=1)
df_smote

# Counting amount of each class
df_smote["class"].value_counts()

# Plottimg resampled values using T-SNE
t_sne_draw(df_smote, 2, 30, 0.6)

# Plottimg resampled values using UMAP
umap_draw(df_smote, 2, 30, 0.6)

# Plottimg original values using T-SNE
t_sne_draw(df_one_hot, 2, 30, 0.6)

# Plottimg original values using UMAP
umap_draw(df_one_hot, 2, 20, 0.6)

"""#Grid search for SVM classifier with SMOTE resampling#

Searching for best parameters
"""

from sklearn.model_selection import GridSearchCV
from sklearn import svm
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import f1_score

# Separating sampled data on test and train
X_train, X_test, y_train, y_test = train_test_split(df_smote.loc[:, df_smote.columns != "class"], df_smote["class"],
                                                    test_size=0.3, shuffle=True)


# SVM
X_test_svm = X_test
y_test_svm = y_test

# KNN
X_test_knn = X_test
y_test_knn = y_test

# RF
X_test_rf = X_test
y_test_rf = y_test

parameters = {"kernel":("linear", "rbf", "sigmoid", "poly"), "C":list(range(1, 11)), "class_weight": [None, "balanced"]}
scoring = ['accuracy','f1_macro', 'recall']
svc = svm.SVC()

clf = GridSearchCV(svc, parameters, n_jobs=4, verbose=3, refit=False, cv=2)

clf.fit(X_train, y_train)

clf.best_params_

"""Training using best parameters according to Grid search"""

# Creating and training classifier with linear kernel
clf = svm.SVC(**clf.best_params_)
clf.fit(X_train, y_train)

"""Testing on sampled data"""

# Predicting values
pred_test_svm = clf.predict(X_test_svm)

pred_svm = pd.Series(pred_test_svm, name="class")

# Making dataframe from predicted values
X_test_svm.reset_index(drop=True, inplace=True)
y_pred_svm = pd.DataFrame(pred_svm)
df_svm = pd.concat([X_test_svm, y_pred_svm], axis=1)
df_svm

# Plottimg predicted resampled values using T-SNE
t_sne_draw(df_svm, 2, 30, 0.6)

# Plottimg predicted resampled values using UMAP
umap_draw(df_svm, 2, 30, 0.6)

# Making dataframe from training values
X_test.reset_index(drop=True, inplace=True)
y_test_ = pd.DataFrame(y_test)
y_test_.reset_index(drop=True, inplace=True)
df_test = pd.concat([X_test, y_test_], axis=1)
df_test

# Plottimg test resampled values using T-SNE
t_sne_draw(df_test, 2, 30, 0.6)

# Plottimg test resampled values using UMAP
umap_draw(df_test, 2, 30, 0.6)

"""Testing on original data"""

# Predicting values
pred_test_svm = clf.predict(X_test_svm_og)

pred_svm = pd.Series(pred_test_svm, name="class")

print(f1_score(pred_test_svm, y_test_svm_og, average="micro"))

# Making dataframe from predicted values
X_test_svm_og.reset_index(drop=True, inplace=True)
y_pred_svm_og = pd.DataFrame(pred_svm)
df_svm_og = pd.concat([X_test_svm_og, y_pred_svm_og], axis=1)
df_svm_og

# Plottimg test original values using T-SNE
t_sne_draw(df_svm_og, 2, 20, 0.6)

# Plottimg test original values using UMAP
umap_draw(df_svm_og, 2, 20, 0.6)

"""#Grid search for KNN classifier with SMOTE resampling#

Searching for best parameters
"""

parameters = {"n_neighbors":list(range(5, 30)), "algorithm":("brute", "kd_tree", "ball_tree"),
              "metric":["minkowski", "manhattan", "euclidean"]}

kneigh = KNeighborsClassifier()

neigh = GridSearchCV(kneigh, parameters, n_jobs=4, verbose=3, refit=False, cv=2)

neigh.fit(X_train, y_train)

neigh.best_params_

"""Training using best parameters according to Grid search"""

neigh = KNeighborsClassifier(**neigh.best_params_)
neigh.fit(X_train, y_train)

"""Testing on sampled data"""

# Predicting values
pred_neigh = clf.predict(X_test_knn)

pred_knn = pd.Series(pred_neigh, name="class")

# Making dataframe from predicted values
X_test_knn.reset_index(drop=True, inplace=True)
y_pred_knn = pd.DataFrame(pred_knn)
df_knn = pd.concat([X_test_knn, y_pred_knn], axis=1)
df_knn

# Plottimg predicted resampled values using T-SNE
t_sne_draw(df_knn, 2, 30, 0.6)

# Plottimg predicted resampled values using UMAP
umap_draw(df_knn, 2, 30, 0.6)

"""Testing on original data"""

# Predicting values
pred_neigh = clf.predict(X_test_knn_og)

pred_knn = pd.Series(pred_neigh, name="class")

print(f1_score(pred_neigh, y_test_knn_og, average="micro"))

# Making dataframe from predicted values
X_test_knn_og.reset_index(drop=True, inplace=True)
y_pred_knn_og = pd.DataFrame(pred_knn)
df_knn_og = pd.concat([X_test_knn_og, y_pred_knn_og], axis=1)
df_knn_og

# Plottimg predicted original values using T-SNE
t_sne_draw(df_knn_og, 2, 20, 0.6)

# Plottimg predicted original values using UMAP
umap_draw(df_knn_og, 2, 20, 0.6)

"""#Grid search for RF classifier with SMOTE resampling#

Searching for best parameters
"""

parameters = {"n_estimators":list(range(100, 200, 25)), "criterion":("gini", "entropy", "log_loss"), "max_depth":list(range(3, 6))}
rf = RandomForestClassifier()

rfc = GridSearchCV(rf, parameters, n_jobs=4, verbose=3, refit=False, cv=2)

rfc.fit(X_train, y_train)

rfc.best_params_

"""Training using best parameters according to Grid search"""

rfc = RandomForestClassifier(**rfc.best_params_)
rfc.fit(X_train, y_train)

"""Testing on resampled data"""

# Predicting values
pred_test_rf = clf.predict(X_test_rf)

pred_rf = pd.Series(pred_test_rf, name="class")

# Making dataframe from predicted values
X_test_rf.reset_index(drop=True, inplace=True)
y_pred_rf = pd.DataFrame(pred_rf)
df_rf = pd.concat([X_test_rf, y_pred_rf], axis=1)
df_rf

# Plottimg predicted resampled values using T-SNE
t_sne_draw(df_rf, 2, 30, 0.6)

# Plottimg predicted resampled values using UMAP
umap_draw(df_rf, 2, 30, 0.6)

"""Testing on original data"""

# Predicting values
pred_test_rf = clf.predict(X_test_rf_og)

pred_rf = pd.Series(pred_test_rf, name="class")

print(f1_score(pred_test_rf, y_test_rf_og, average="micro"))

# Making dataframe from predicted values
X_test_rf_og.reset_index(drop=True, inplace=True)
y_pred_rf_og = pd.DataFrame(pred_rf)
df_rf_og = pd.concat([X_test_rf_og, y_pred_rf_og], axis=1)
df_rf_og

# Plottimg predicted original values using T-SNE
t_sne_draw(df_rf_og, 2, 20, 0.6)

# Plottimg predicted original values using UMAP
umap_draw(df_rf_og, 2, 20, 0.6)

"""#Resampling data using Borderline SMOTE-1#"""

from imblearn.over_sampling import BorderlineSMOTE

bsm = BorderlineSMOTE(sampling_strategy="not majority", random_state=42, k_neighbors=1, n_jobs=4, m_neighbors=2, kind="borderline-1")
X_bsm, y_bsm = bsm.fit_resample(df_one_hot.loc[:, df_one_hot.columns != "class"], df_one_hot["class"])

y_border_smote = pd.DataFrame(y_bsm)
y_border_smote.reset_index(drop=True, inplace=True)
df_border_smote = pd.concat([X_bsm, y_border_smote], axis=1)
df_border_smote

# Counting amount of each class
df_border_smote["class"].value_counts()

# Plottimg resampled values using T-SNE
t_sne_draw(df_border_smote, 2, 20, 0.6)

# Plottimg resampled values using UMAP
umap_draw(df_border_smote, 2, 20, 0.6)

"""#Grid search for SVM classifier with Borderline SMOTE-1 resampling#

Searching for best parameters
"""

# Separating on test and train
X_train, X_test, y_train, y_test = train_test_split(df_border_smote.loc[:, df_border_smote.columns != "class"], df_border_smote["class"],
                                                    test_size=0.3, shuffle=True)


# SVM
X_test_svm = X_test
y_test_svm = y_test

# KNN
X_test_knn = X_test
y_test_knn = y_test

# RF
X_test_rf = X_test
y_test_rf = y_test

parameters = {"kernel":("linear", "rbf", "sigmoid", "poly"), "C":list(range(1, 11)), "class_weight": [None, "balanced"]}
scoring = ['accuracy','f1_macro', 'recall']
svc = svm.SVC()

clf = GridSearchCV(svc, parameters, n_jobs=4, verbose=3, refit=False, cv=2)

clf.fit(X_train, y_train)

clf.best_params_

"""Training using best parameters according to Grid search"""

# Creating and training classifier with linear kernel
clf = svm.SVC(**clf.best_params_)
clf.fit(X_train, y_train)

"""Testing on sampled data"""

# Predicting values
pred_test_svm = clf.predict(X_test_svm)

pred_svm = pd.Series(pred_test_svm, name="class")

# Making dataframe from predicted values
X_test_svm.reset_index(drop=True, inplace=True)
y_pred_svm = pd.DataFrame(pred_svm)
df_svm = pd.concat([X_test_svm, y_pred_svm], axis=1)
df_svm

# Plottimg predicted resampled values using T-SNE
t_sne_draw(df_svm, 2, 30, 0.6)

# Plottimg predicted resampled values using UMAP
umap_draw(df_svm, 2, 30, 0.6)

# Making dataframe from training values
X_test.reset_index(drop=True, inplace=True)
y_test_ = pd.DataFrame(y_test)
y_test_.reset_index(drop=True, inplace=True)
df_test = pd.concat([X_test, y_test_], axis=1)
df_test

# Plottimg test resampled values using T-SNE
t_sne_draw(df_test, 2, 30, 0.6)

# Plottimg test resampled values using UMAP
umap_draw(df_test, 2, 30, 0.6)

"""Testing on original data"""

# Predicting values
pred_test_svm = clf.predict(X_test_svm_og)

pred_svm = pd.Series(pred_test_svm, name="class")

print(f1_score(pred_test_svm, y_test_svm_og, average="micro"))

# Making dataframe from predicted values
X_test_svm_og.reset_index(drop=True, inplace=True)
y_pred_svm_og = pd.DataFrame(pred_svm)
df_svm_og = pd.concat([X_test_svm_og, y_pred_svm_og], axis=1)
df_svm_og

# Plottimg predicted original values using T-SNE
t_sne_draw(df_svm_og, 2, 20, 0.6)

# Plottimg predicted original values using UMAP
umap_draw(df_svm_og, 2, 20, 0.6)

"""#Grid search for KNN classifier with Borderline SMOTE-1 resampling#

Searching for best parameters
"""

parameters = {"n_neighbors":list(range(5, 30)), "algorithm":("brute", "kd_tree", "ball_tree"),
              "metric":["minkowski", "manhattan", "euclidean"]}

kneigh = KNeighborsClassifier()

neigh = GridSearchCV(kneigh, parameters, n_jobs=4, verbose=3, refit=False, cv=2)

neigh.fit(X_train, y_train)

neigh.best_params_

"""Training using best parameters according to Grid search"""

neigh = KNeighborsClassifier(**neigh.best_params_)
neigh.fit(X_train, y_train)

"""Testing on sampled data"""

# Predicting values
pred_neigh = clf.predict(X_test_knn)

pred_knn = pd.Series(pred_neigh, name="class")

# Making dataframe from predicted values
X_test_knn.reset_index(drop=True, inplace=True)
y_pred_knn = pd.DataFrame(pred_knn)
df_knn = pd.concat([X_test_knn, y_pred_knn], axis=1)
df_knn

# Plottimg predicted resampled values using T-SNE
t_sne_draw(df_knn, 2, 30, 0.6)

# Plottimg predicted resampled values using UMAP
umap_draw(df_knn, 2, 30, 0.6)

"""Testing on original data"""

# Predicting values
pred_neigh = clf.predict(X_test_knn_og)

pred_knn = pd.Series(pred_neigh, name="class")

print(f1_score(pred_neigh, y_test_knn_og, average="micro"))

# Making dataframe from predicted values
X_test_knn_og.reset_index(drop=True, inplace=True)
y_pred_knn_og = pd.DataFrame(pred_knn)
df_knn_og = pd.concat([X_test_knn_og, y_pred_knn_og], axis=1)
df_knn_og

# Plottimg predicted original values using T-SNE
t_sne_draw(df_knn_og, 2, 20, 0.6)

# Plottimg predicted original values using UMAP
umap_draw(df_knn_og, 2, 20, 0.6)

"""#Grid search for RF classifier with Borderline SMOTE-1 resampling#

Searching for best parameters
"""

parameters = {"n_estimators":list(range(100, 200, 25)), "criterion":("gini", "entropy", "log_loss"), "max_depth":list(range(3, 6))}
rf = RandomForestClassifier()

rfc = GridSearchCV(rf, parameters, n_jobs=4, verbose=3, refit=False, cv=2)

rfc.fit(X_train, y_train)

rfc.best_params_

"""Training using best parameters according to Grid search"""

rfc = RandomForestClassifier(**rfc.best_params_)
rfc.fit(X_train, y_train)

"""Testing on sampled data"""

# Predicting values
pred_test_rf = clf.predict(X_test_rf)

pred_rf = pd.Series(pred_test_rf, name="class")

# Making dataframe from predicted values
X_test_rf.reset_index(drop=True, inplace=True)
y_pred_rf = pd.DataFrame(pred_rf)
df_rf = pd.concat([X_test_rf, y_pred_rf], axis=1)
df_rf

# Plottimg predicted resampled values using T-SNE
t_sne_draw(df_rf, 2, 30, 0.6)

# Plottimg predicted resampled values using UMAP
umap_draw(df_rf, 2, 30, 0.6)

"""Testing on original data"""

# Predicting values
pred_test_rf = clf.predict(X_test_rf_og)

pred_rf = pd.Series(pred_test_rf, name="class")

print(f1_score(pred_test_rf, y_test_rf_og, average="micro"))

# Making dataframe from predicted values
X_test_rf_og.reset_index(drop=True, inplace=True)
y_pred_rf_og = pd.DataFrame(pred_rf)
df_rf_og = pd.concat([X_test_rf_og, y_pred_rf_og], axis=1)
df_rf_og

# Plottimg predicted original values using T-SNE
t_sne_draw(df_rf_og, 2, 20, 0.6)

# Plottimg predicted original values using UMAP
umap_draw(df_rf_og, 2, 20, 0.6)

"""#Resampling data using Borderline SMOTE-2#"""

bsm = BorderlineSMOTE(sampling_strategy="not majority", random_state=42, k_neighbors=1, n_jobs=4, m_neighbors=2, kind="borderline-2")
X_bsm2, y_bsm2 = bsm.fit_resample(df_one_hot.loc[:, df_one_hot.columns != "class"], df_one_hot["class"])

y_border_smote = pd.DataFrame(y_bsm2)
y_border_smote.reset_index(drop=True, inplace=True)
df_border_smote2 = pd.concat([X_bsm2, y_border_smote], axis=1)
df_border_smote2

# Counting amount of each class
df_border_smote2["class"].value_counts()

# Plottimg resampled values using T-SNE
t_sne_draw(df_border_smote2, 2, 30, 0.6)

# Plottimg resampled values using UMAP
umap_draw(df_border_smote2, 2, 30, 0.6)

"""#Grid search for SVM classifier with Borderline SMOTE-2 resampling#

Searching for best parameters
"""

# Separating on test and train
X_train, X_test, y_train, y_test = train_test_split(df_border_smote2.loc[:, df_border_smote2.columns != "class"], df_border_smote2["class"],
                                                    test_size=0.3, shuffle=True)


# SVM
X_test_svm = X_test
y_test_svm = y_test

# KNN
X_test_knn = X_test
y_test_knn = y_test

# RF
X_test_rf = X_test
y_test_rf = y_test

parameters = {"kernel":("linear", "rbf", "sigmoid", "poly"), "C":list(range(1, 11)), "class_weight": [None, "balanced"]}
scoring = ['accuracy','f1_macro', 'recall']
svc = svm.SVC()

clf = GridSearchCV(svc, parameters, n_jobs=4, verbose=3, refit=False, cv=2)

clf.fit(X_train, y_train)

clf.best_params_

"""Training using best parameters according to Grid search"""

# Creating and training classifier with linear kernel
clf = svm.SVC(**clf.best_params_)
clf.fit(X_train, y_train)

"""Testing on sampled data"""

# Predicting values
pred_test_svm = clf.predict(X_test_svm)

pred_svm = pd.Series(pred_test_svm, name="class")

# Making dataframe from predicted values
X_test_svm.reset_index(drop=True, inplace=True)
y_pred_svm = pd.DataFrame(pred_svm)
df_svm = pd.concat([X_test_svm, y_pred_svm], axis=1)
df_svm

# Plottimg predicted resampled values using T-SNE
t_sne_draw(df_svm, 2, 30, 0.6)

# Plottimg predicted resampled values using UMAP
umap_draw(df_svm, 2, 30, 0.6)

# Making dataframe from training values
X_test.reset_index(drop=True, inplace=True)
y_test_ = pd.DataFrame(y_test)
y_test_.reset_index(drop=True, inplace=True)
df_test = pd.concat([X_test, y_test_], axis=1)
df_test

# Plottimg test resampled values using T-SNE
t_sne_draw(df_test, 2, 30, 0.6)

# Plottimg test resampled values using UMAP
umap_draw(df_test, 2, 30, 0.6)

"""Testing on original data"""

# Predicting values
pred_test_svm = clf.predict(X_test_svm_og)

pred_svm = pd.Series(pred_test_svm, name="class")

print(f1_score(pred_test_svm, y_test_svm_og, average="micro"))

# Making dataframe from predicted values
X_test_svm_og.reset_index(drop=True, inplace=True)
y_pred_svm_og = pd.DataFrame(pred_svm)
df_svm_og = pd.concat([X_test_svm_og, y_pred_svm_og], axis=1)
df_svm_og

# Plottimg predicted original values using T-SNE
t_sne_draw(df_svm_og, 2, 20, 0.6)

# Plottimg predicted original values using UMAP
umap_draw(df_svm_og, 2, 20, 0.6)

"""#Grid search for KNN classifier with Borderline SMOTE-2 resampling#

Searching for best parameters
"""

parameters = {"n_neighbors":list(range(5, 30)), "algorithm":("brute", "kd_tree", "ball_tree"),
              "metric":["minkowski", "manhattan", "euclidean"]}

kneigh = KNeighborsClassifier()

neigh = GridSearchCV(kneigh, parameters, n_jobs=4, verbose=3, refit=False, cv=2)

neigh.fit(X_train, y_train)

neigh.best_params_

"""Training using best parameters according to Grid search"""

neigh = KNeighborsClassifier(**neigh.best_params_)
neigh.fit(X_train, y_train)

"""Testing on sampled data"""

# Predicting values
pred_neigh = clf.predict(X_test_knn)

pred_knn = pd.Series(pred_neigh, name="class")

# Making dataframe from predicted values
X_test_knn.reset_index(drop=True, inplace=True)
y_pred_knn = pd.DataFrame(pred_knn)
df_knn = pd.concat([X_test_knn, y_pred_knn], axis=1)
df_knn

# Plottimg predicted resampled values using T-SNE
t_sne_draw(df_knn, 2, 30, 0.6)

# Plottimg predicted resampled values using UMAP
umap_draw(df_knn, 2, 30, 0.6)

"""Testing on original data"""

# Predicting values
pred_neigh = clf.predict(X_test_knn_og)

pred_knn = pd.Series(pred_neigh, name="class")

print(f1_score(pred_neigh, y_test_knn_og, average="micro"))

# Making dataframe from predicted values
X_test_knn_og.reset_index(drop=True, inplace=True)
y_pred_knn_og = pd.DataFrame(pred_knn)
df_knn_og = pd.concat([X_test_knn_og, y_pred_knn_og], axis=1)
df_knn_og

# Plottimg predicted original values using T-SNE
t_sne_draw(df_knn_og, 2, 20, 0.6)

# Plottimg predicted original values using UMAP
umap_draw(df_knn_og, 2, 20, 0.6)

"""#Grid search for RF classifier with Borderline SMOTE-2 resampling#

Searching for best parameters
"""

parameters = {"n_estimators":list(range(100, 200, 25)), "criterion":("gini", "entropy", "log_loss"), "max_depth":list(range(3, 6))}
rf = RandomForestClassifier()

rfc = GridSearchCV(rf, parameters, n_jobs=4, verbose=3, refit=False, cv=2)

rfc.fit(X_train, y_train)

rfc.best_params_

"""Training using best parameters according to Grid search"""

rfc = RandomForestClassifier(**rfc.best_params_)
rfc.fit(X_train, y_train)

"""Testing on sampled data"""

# Predicting values
pred_test_rf = clf.predict(X_test_rf)

pred_rf = pd.Series(pred_test_rf, name="class")

# Making dataframe from predicted values
X_test_rf.reset_index(drop=True, inplace=True)
y_pred_rf = pd.DataFrame(pred_rf)
df_rf = pd.concat([X_test_rf, y_pred_rf], axis=1)
df_rf

# Plottimg predicted resampled values using T-SNE
t_sne_draw(df_rf, 2, 30, 0.6)

# Plottimg predicted resampled values using UMAP
umap_draw(df_rf, 2, 30, 0.6)

"""Testing on original data"""

# Predicting values
pred_test_rf = clf.predict(X_test_rf_og)

pred_rf = pd.Series(pred_test_rf, name="class")

print(f1_score(pred_test_rf, y_test_rf_og, average="micro"))

# Making dataframe from predicted values
X_test_rf_og.reset_index(drop=True, inplace=True)
y_pred_rf_og = pd.DataFrame(pred_rf)
df_rf_og = pd.concat([X_test_rf_og, y_pred_rf_og], axis=1)
df_rf_og

# Plottimg predicted original values using T-SNE
t_sne_draw(df_rf_og, 2, 20, 0.6)

# Plottimg predicted original values using UMAP
umap_draw(df_rf_og, 2, 20, 0.6)